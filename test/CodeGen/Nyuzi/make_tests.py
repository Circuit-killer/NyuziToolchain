import sys

#
# Generate all permuations of arithmetic instruction forms. I automate this
# because there are so many variations of vector/scalar/masked forms. This
# must be run manually when the instruction set changes.
#
# python make_tests.py
#


def get_type_string(is_vector, is_float):
    if is_float:
        rettype = 'float'
    else:
        rettype = 'i32'

    if is_vector:
        rettype = '<16 x ' + rettype + '>'

    return rettype

binary_ops = [
    ('or', 'or'),
    ('and', 'and'),
    ('xor', 'xor'),
    ('add', 'add_i'),
    ('sub', 'sub_i'),
    ('ashr', 'ashr'),
    ('lshr', 'shr'),
    ('shl', 'shl'),
    ('fadd', 'add_f'),
    ('fsub', 'sub_f'),
    ('fmul', 'mul_f')
]

reg_instruction_types = [
    ('s', 's', False),
    ('v', 's', False),
    ('v', 's', True),
    ('v', 'v', False),
    ('v', 'v', True)
]

imm_instruction_types = [
    ('s', 's', False),
    ('v', 'v', False),
    ('v', 'v', True),
    ('v', 's', False),
    ('v', 's', True)
]

op_test_fp = open('operator_tests.ll', 'w')
op_test_fp.write('''; RUN: llc -mtriple nyuzi-elf %s -o - | FileCheck %s
; This file is autogenerated by make_tests.py. Do not edit.
;
; This test exhaustively validates arithmetic and compare instruction types,
; with all supported formats. The exception are scalar-only comparisons, which
; are in scalar_compare.ll because LLVM performs a lot of arbitrary transforms
; on them.

target triple = "nyuzi"

declare <16 x i32> @llvm.nyuzi.__builtin_nyuzi_vector_mixi(i32 %mask, <16 x i32> %a, <16 x i32> %b)
declare <16 x float> @llvm.nyuzi.__builtin_nyuzi_vector_mixf(i32 %mask, <16 x float> %a, <16 x float> %b)
declare i32 @llvm.nyuzi.__builtin_nyuzi_mask_cmpi_sgt(<16 x i32> %a, <16 x i32> %b)
declare i32 @llvm.nyuzi.__builtin_nyuzi_mask_cmpi_sge(<16 x i32> %a, <16 x i32> %b)
declare i32 @llvm.nyuzi.__builtin_nyuzi_mask_cmpi_slt(<16 x i32> %a, <16 x i32> %b)
declare i32 @llvm.nyuzi.__builtin_nyuzi_mask_cmpi_sle(<16 x i32> %a, <16 x i32> %b)
declare i32 @llvm.nyuzi.__builtin_nyuzi_mask_cmpi_eq(<16 x i32> %a, <16 x i32> %b)
declare i32 @llvm.nyuzi.__builtin_nyuzi_mask_cmpi_ne(<16 x i32> %a, <16 x i32> %b)
declare i32 @llvm.nyuzi.__builtin_nyuzi_mask_cmpi_ugt(<16 x i32> %a, <16 x i32> %b)
declare i32 @llvm.nyuzi.__builtin_nyuzi_mask_cmpi_uge(<16 x i32> %a, <16 x i32> %b)
declare i32 @llvm.nyuzi.__builtin_nyuzi_mask_cmpi_ult(<16 x i32> %a, <16 x i32> %b)
declare i32 @llvm.nyuzi.__builtin_nyuzi_mask_cmpi_ule(<16 x i32> %a, <16 x i32> %b)
declare i32 @llvm.nyuzi.__builtin_nyuzi_mask_cmpf_gt(<16 x float> %a, <16 x float> %b)
declare i32 @llvm.nyuzi.__builtin_nyuzi_mask_cmpf_ge(<16 x float> %a, <16 x float> %b)
declare i32 @llvm.nyuzi.__builtin_nyuzi_mask_cmpf_lt(<16 x float> %a, <16 x float> %b)
declare i32 @llvm.nyuzi.__builtin_nyuzi_mask_cmpf_le(<16 x float> %a, <16 x float> %b)

''')

########################################
# Arithmetic Tests
########################################

for llvmop, mnemonic in binary_ops:
    is_float = mnemonic[-2:] == '_f'

    # Register operations
    for s1regt, s2regt, is_masked in reg_instruction_types:
        is_vector = s1regt == 'v'
        rettype = get_type_string(is_vector, is_float)
        funcname = 'test_' + llvmop + s1regt + \
            s2regt + ('m' if is_masked else '')
        op_test_fp.write('define ' + rettype + ' @' +
                         funcname + '(' + rettype + ' %a, ')
        op_test_fp.write(get_type_string(s2regt == 'v', is_float) + ' %b' +
                         (', i32 %mask' if is_masked else '') + ') { ; CHECK: ' + funcname + ':\n')

        # Expand scalar to vector type
        if s1regt == 'v' and s2regt == 's':
            op_test_fp.write('  %single = insertelement ' + rettype + ' undef, ' +
                             get_type_string(s2regt == 'v', is_float) + ' %b, i32 0\n')
            op_test_fp.write('  %splat = shufflevector ' + rettype +
                             ' %single, ' + rettype + ' undef, <16 x i32> zeroinitializer\n')
            op_test_fp.write('  %1 = ' + llvmop + ' ' +
                             rettype + ' %a,%splat\n')
        else:
            op_test_fp.write('  %1 = ' + llvmop + ' ' + rettype + ' %a,%b\n')

        if is_masked:
            op_test_fp.write('  %2 = call ' + rettype +
                             ' @llvm.nyuzi.__builtin_nyuzi_vector_mix' + ('f' if is_float else 'i') + '(i32 %mask, ' + rettype + ' %1, ' + rettype + ' %a)\n')
            op_test_fp.write('  ; CHECK: ' + mnemonic + '_mask ' + s1regt +
                             '{{[0-9]+}}, s{{[0-9]+}}, ' + s1regt + '{{[0-9]+}}, ' + s2regt + '{{[0-9]+}}\n')
            op_test_fp.write('  ret ' + rettype + ' %2\n}\n\n')
        else:
            op_test_fp.write('  ; CHECK: ' + mnemonic + ' ' + s1regt +
                             '{{[0-9]+}}, ' + s1regt + '{{[0-9]+}}, ' + s2regt + '{{[0-9]+}}\n')
            op_test_fp.write('  ret ' + rettype + ' %1\n}\n\n')

    if is_float:
        continue  # Can't do immediate for FP instructions

    # Immediate operations
    for dregt, s1regt, is_masked in imm_instruction_types:
        # XXXX Ugh. LLVM converts a scalar immediate subtract into a add with
        # a negative immediate. Skip this test. :(
        if mnemonic == 'sub_i' and dregt == 's' and s1regt == 's':
            continue

        rettype = get_type_string(dregt == 'v', is_float)
        funcname = 'test_' + llvmop + dregt + \
            s1regt + 'I' + ('m' if is_masked else '')
        op_test_fp.write('define ' + rettype + ' @' + funcname +
                         '(' + get_type_string(s1regt == 'v', is_float) + ' %a')
        if is_masked:
            op_test_fp.write(', i32 %mask) { ')
        else:
            op_test_fp.write(') { ')

        op_test_fp.write('; CHECK ' + funcname + ':\n')

        if dregt == 'v' and s1regt == 's':
            op_test_fp.write('  %single = insertelement ' +
                             rettype + ' undef, i32 %a, i32 0\n')
            op_test_fp.write('  %splat = shufflevector ' + rettype +
                             ' %single, ' + rettype + ' undef, <16 x i32> zeroinitializer\n')
            op_test_fp.write('  %1 = ' + llvmop + ' ' + rettype + ' %splat, ')
        else:
            op_test_fp.write('  %1 = ' + llvmop + ' ' + rettype + ' %a, ')

        if dregt == 'v':
            op_test_fp.write(
                '<i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27>\n')
        else:
            op_test_fp.write('27\n')

        if is_masked:
            op_test_fp.write('  %2 = call ' + rettype +
                             ' @llvm.nyuzi.__builtin_nyuzi_vector_mixi(i32 %mask, ' + rettype + ' %1, ' + rettype)
            if dregt == 'v' and s1regt == 's':
                op_test_fp.write(' %splat)\n')
            else:
                op_test_fp.write(' %a)\n')

            op_test_fp.write('  ; CHECK: ' + mnemonic + '_mask ' + dregt +
                             '{{[0-9]+}}, s{{[0-9]+}}, ' + s1regt + '{{[0-9]+}}, ' + '27\n')
            op_test_fp.write('  ret ' + rettype + ' %2\n}\n\n')
        else:
            op_test_fp.write('  ; CHECK: ' + mnemonic + ' ' + dregt +
                             '{{[0-9]+}}, ' + s1regt + '{{[0-9]+}}, ' + '27\n')
            op_test_fp.write('  ret ' + rettype + ' %1\n}\n\n')

########################################
# Vector Compare tests
########################################

compare_tests = [
    ('i_sgt', 'gt_i'),
    ('i_sge', 'ge_i'),
    ('i_slt', 'lt_i'),
    ('i_sle', 'le_i'),
    ('i_eq', 'eq_i'),
    ('i_ne', 'ne_i'),
    ('i_ugt', 'gt_u'),
    ('i_uge', 'ge_u'),
    ('i_ult', 'lt_u'),
    ('i_ule', 'le_u'),
    ('f_gt', 'gt_f'),
    ('f_ge', 'ge_f'),
    ('f_lt', 'lt_f'),
    ('f_le', 'le_f'),
]

for intr_suffix, instr_suffix in compare_tests:
    # Vector op vector
    etype = 'float' if instr_suffix[-2:] == '_f' else 'i32'

    op_test_fp.write('define i32 @cmp' + intr_suffix + 'vv(<16 x ' + etype +
                     '> %a, <16 x ' + etype + '> %b) {	; CHECK: cmp' + intr_suffix + 'vv:\n')
    op_test_fp.write('  %c = call i32 @llvm.nyuzi.__builtin_nyuzi_mask_cmp' +
                     intr_suffix + '(<16 x ' + etype + '> %a, <16 x ' + etype + '> %b)\n')
    op_test_fp.write('  ; CHECK: cmp' + instr_suffix +
                     ' s{{[0-9]+}}, v{{[0-9]+}}, v{{[0-9]+}}\n')
    op_test_fp.write('  ret i32 %c\n')
    op_test_fp.write('}\n\n')

    # Vector op scalar
    op_test_fp.write('define i32 @cmp' + intr_suffix + 'vs(<16 x ' + etype +
                     '> %a, ' + etype + ' %b) {	; CHECK: cmp' + intr_suffix + 'vs:\n')
    op_test_fp.write('  %single = insertelement <16 x ' +
                     etype + '> undef, ' + etype + ' %b, i32 0\n')
    op_test_fp.write('  %splat = shufflevector <16 x ' + etype +
                     '> %single, <16 x ' + etype + '> undef, <16 x i32> zeroinitializer\n')

    op_test_fp.write('  %c = call i32 @llvm.nyuzi.__builtin_nyuzi_mask_cmp' +
                     intr_suffix + '(<16 x ' + etype + '> %a, <16 x ' + etype + '> %splat)\n')
    op_test_fp.write('  ; CHECK: cmp' + instr_suffix +
                     ' s{{[0-9]+}}, v{{[0-9]+}}, s{{[0-9]+}}\n')
    op_test_fp.write('  ret i32 %c\n')
    op_test_fp.write('}\n\n')

    if instr_suffix[-2:] == '_f':
        continue

    # Vector op immediate
    op_test_fp.write('define i32 @cmp' + intr_suffix + 'vI(<16 x ' + etype +
                     '> %a, <16 x ' + etype + '> %b) {	; CHECK: cmp' + intr_suffix + 'vI:\n')
    op_test_fp.write('  %c = call i32 @llvm.nyuzi.__builtin_nyuzi_mask_cmp' + intr_suffix + '(<16 x ' + etype +
                     '> %a, <16 x i32> <i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27>)\n')
    op_test_fp.write('  ; CHECK: cmp' + instr_suffix +
                     ' s{{[0-9]+}}, v{{[0-9]+}}, 27\n')
    op_test_fp.write('  ret i32 %c\n')
    op_test_fp.write('}\n\n')
