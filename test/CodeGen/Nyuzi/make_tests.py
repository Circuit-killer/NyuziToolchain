import sys

#
# Generate all permuations of arithmetic instruction forms. I automate this
# because there are so many variations of vector/scalar/masked forms. This
# must be run manually when the instruction set changes.
#
# python make_tests.py
#

def get_type_string(is_vector, is_float):
    if is_float:
        rettype = 'float'
    else:
        rettype = 'i32'

    if is_vector:
        rettype = '<16 x ' + rettype + '>'

    return rettype

binary_ops = [
    ('or', 'or'),
    ('and', 'and'),
    ('xor', 'xor'),
    ('add', 'add_i'),
    ('sub', 'sub_i'),
    ('ashr', 'ashr'),
    ('lshr', 'shr'),
    ('shl', 'shl'),
    ('fadd', 'add_f'),
    ('fsub', 'sub_f'),
    ('fmul', 'mul_f')
]

reg_instruction_types = [
    ('s', 's', False),
    ('v', 's', False),
    ('v', 's', True),
    ('v', 'v', False),
    ('v', 'v', True)
]

imm_instruction_types = [
    ('s', 's', False),
    ('v', 'v', False),
    ('v', 'v', True),
    ('v', 's', False),
    ('v', 's', True)
]

op_test_fp = open('operator_tests.ll', 'w')
op_test_fp.write('''; RUN: llc -mtriple nyuzi-elf %s -o - | FileCheck %s
; This file is autogenerated by make_tests.py. Do not edit.

target triple = "nyuzi"

declare <16 x i32> @llvm.nyuzi.__builtin_nyuzi_vector_mixi(i32 %mask, <16 x i32> %a, <16 x i32> %b)
declare <16 x float> @llvm.nyuzi.__builtin_nyuzi_vector_mixf(i32 %mask, <16 x float> %a, <16 x float> %b)
''')

# Arithmetic types
for llvmop, mnemonic in binary_ops:
    is_float = mnemonic[-2:] == '_f'

    # Register operations
    for s1regt, s2regt, is_masked in reg_instruction_types:
        is_vector = s1regt == 'v'
        rettype = get_type_string(is_vector, is_float)
        funcname = 'test_' + llvmop + s1regt + \
            s2regt + ('m' if is_masked else '')
        op_test_fp.write('define ' + rettype + ' @' + funcname + '(' + rettype + ' %a, ')
        op_test_fp.write(get_type_string(s2regt == 'v', is_float) + ' %b' + (', i32 %mask' if is_masked else '') + ') { ; CHECK: ' + funcname + ':\n')

        # Expand scalar to vector type
        if s1regt == 'v' and s2regt == 's':
            op_test_fp.write('    %single = insertelement ' + rettype + ' undef, ' + get_type_string(s2regt == 'v', is_float) + ' %b, i32 0\n')
            op_test_fp.write('    %splat = shufflevector ' + rettype + ' %single, ' + rettype + ' undef, <16 x i32> zeroinitializer\n')
            op_test_fp.write('    %1 = ' + llvmop + ' ' + rettype + ' %a,%splat\n')
        else:
            op_test_fp.write('    %1 = ' + llvmop + ' ' + rettype + ' %a,%b\n')

        if is_masked:
            op_test_fp.write('    %2 = call ' + rettype +
                  ' @llvm.nyuzi.__builtin_nyuzi_vector_mix' + ('f' if is_float else 'i') + '(i32 %mask, ' + rettype + ' %1, ' + rettype + ' %a)\n')
            op_test_fp.write('    ; CHECK: ' + mnemonic + '_mask ' + s1regt +
                  '{{[0-9]+}}, s{{[0-9]+}}, ' + s1regt + '{{[0-9]+}}, ' + s2regt + '{{[0-9]+}}\n')
            op_test_fp.write('    ret ' + rettype + ' %2\n}\n\n')
        else:
            op_test_fp.write('    ; CHECK: ' + mnemonic + ' ' + s1regt +
                  '{{[0-9]+}}, ' + s1regt + '{{[0-9]+}}, ' + s2regt + '{{[0-9]+}}\n')
            op_test_fp.write('    ret ' + rettype + ' %1\n}\n\n')

    if is_float:
        continue  # Can't do immediate for FP instructions

    # Immediate operations
    for dregt, s1regt, is_masked in imm_instruction_types:
        # XXXX Ugh. LLVM converts a scalar immediate subtract into a add with
        # a negative immediate. Skip this test. :(
        if mnemonic == 'sub_i' and dregt == 's' and s1regt == 's':
            continue

        rettype = get_type_string(dregt == 'v', is_float)
        funcname = 'test_' + llvmop + dregt + s1regt + 'I' + ('m' if is_masked else '')
        op_test_fp.write('define ' + rettype + ' @' + funcname + '(' + get_type_string(s1regt == 'v', is_float) + ' %a')
        if is_masked:
            op_test_fp.write(', i32 %mask) { ')
        else:
            op_test_fp.write(') { ')

        op_test_fp.write('; CHECK ' + funcname + ':\n')

        if dregt == 'v' and s1regt == 's':
            op_test_fp.write('    %single = insertelement ' + rettype + ' undef, i32 %a, i32 0\n')
            op_test_fp.write('    %splat = shufflevector ' + rettype + ' %single, ' + rettype + ' undef, <16 x i32> zeroinitializer\n')
            op_test_fp.write('    %1 = ' + llvmop + ' ' + rettype + ' %splat, ')
        else:
            op_test_fp.write('    %1 = ' + llvmop + ' ' + rettype + ' %a, ')


        if dregt == 'v':
            op_test_fp.write('<i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27>\n')
        else:
            op_test_fp.write('27\n')

        if is_masked:
            op_test_fp.write('    %2 = call ' + rettype +
                  ' @llvm.nyuzi.__builtin_nyuzi_vector_mixi(i32 %mask, ' + rettype + ' %1, ' + rettype)
            if dregt == 'v' and s1regt == 's':
                op_test_fp.write(' %splat)\n')
            else:
                op_test_fp.write(' %a)\n')

            op_test_fp.write('    ; CHECK: ' + mnemonic + '_mask ' + dregt +
                  '{{[0-9]+}}, s{{[0-9]+}}, ' + s1regt + '{{[0-9]+}}, ' + '27\n')
            op_test_fp.write('    ret ' + rettype + ' %2\n}\n\n')
        else:
            op_test_fp.write('    ; CHECK: ' + mnemonic + ' ' + dregt +
                  '{{[0-9]+}}, ' + s1regt + '{{[0-9]+}}, ' + '27\n')
            op_test_fp.write('    ret ' + rettype + ' %1\n}\n\n')
